-*- Text -*- 

* design issues

** locking for library functions

We've got a *big-compiler-lock* around all use of the compiler and
fasloader (they are mutually recursive in the presence of eval-when
forms)

Other areas that may need serious serialization are
the disassembler
pcl (ha ha ha)
the printer?
the reader?

* seriously broken : affecting correct running

1) allocation locking still not completely done: we're not sure what
happens if two threads simultaneously create a new region, but the
desired effect is "nothing bad"

2) need spinlock implementation in C
2a) lock around all_threads
2b) allocation locking, see (1)
2c) add_thread_to_queue

3) setup_i386_stack_scav in purify.c needs doing for multiple threads

4) need some command to switch the foreground process

i) get spinlock
ii) thread on queue? shuffle it to head, release spinlock
iii) thread not on queue?  
     release spinlock
     Send it SIGTRAP 
     when it appears on the queue, repeat from step i)
iv) free mutex

5) background/stopped threads need to ignore SIGINT

6) when a foreground thread exits, we should pick some other thread to
be foreground next.  For best results this needs to be done by the
parent thread (the child could have exited in an abrupt fashion) and
entails (free-mutex *session-lock*) - the next in line will pick up.

What do we do if there are no remaining foreground threads, but there
are background threads?  (a) exit, (b) sit here quietly, (c) attempt
to start a foreground thread, (d) background the toplevel as well?

7) make-listener-thread should attempt controlling tty stuff so that ^C
can be delivered to it

* broken but uninteresting or cosmetic

8) grow tlv when full

9) fix ROOM

10) reuse ldt slots belonging to dead threads

11) fix other runtime stuff that has been temporarily ripped out
 - control stack scrubbing, chiefly

12) look critically at some of the asserts and loses scattered
    throughout C and work out a sane error recovery strategy that
    doesn't involve dying every time

13) we're not actually SMP-safe, because we use CMPXCHG without a LOCK
    prefix.  It would be nice to have some smart way to detect SMP

* code cleanup

14) Some of the static symbols also have static tls offsets and the
    code that accesses them could be a lot shorter (faster is nice,
    but avoiding allocating a register is even nicer) if these were
    known at host-1 compile time

15) allocate-on-same-page stuff in gc_find_freeish_pages needs
    re-enabling to avoid massive heap fragmentation

