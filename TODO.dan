* stuff that needs to happen before it will run

14) allocation and gc needs fairly serious attention.  There is only
    one ALLOCATION-POINTER, access to which is not locked (other than
    by PA).

ok, how are going to do allocation

a) we should make some kind of token effort to keep allocation-pointer
current, but as long as it overreads it's not a big deal.  Suggestion:
when creating a new region, set it to the end of that region (unless
it's already higher than that)

b) how do we indicate to the gc that now is not a good time to collect stuff
because we have non-roots in our region?

we need some lind of locking:
1) lots of threads can allocate at once, if allocation happens
 within an open region
2) creating a new region should probably be a one-at-a-time operation
3) if any thread is allocating, no thread is allowed to gc

Note that this means gc cannot be called from within the allocator:
the check for need-to-gc must happen in such a way that the allocator
lock is free before gc is triggered.  Ideally, the allocation attempt
should then be repeated after the gc has finished.

there is 

c) can we give each thread an open region of its own so it doesn't
have to lock against other threads for allocation?

alloc() is wired to use current_region_free_pointer, which is assigned
from boxed_region.free_pointer (similar dependency exists between 
current_region_end_addr, boxed_region.end_addr;

eventually we call gc_general_alloc which uses my_region internally
    struct alloc_region *my_region = 
      unboxed_p ? &unboxed_region : &boxed_region;

update_page_write_prot(int page) looks in the currently open regions.
A whole bunch of places close all (both) open regions, and would need
updating to loop through threads and make sure everything is shut.

The unboxed region support is used for copying bignums and stuff like
that: there's no way to allocate directly into it, but gc knows how to
get to it for appropriate kinds of object.  That means we only need
one of it

Is the boxed_region set to something funny during gc?  Yes, but that's
not our problem

d) do we do a further bout of gencgc refactoring first? 

19) should we put our new static symbols in early-impl.lisp ?

20) how come genesis apparently works?  perhaps it doesn't

21) add a lisp interface to init_thread

* stuff that can be fixed later

2) grow tlv when full

10) locking

12) fix ROOM

13) fix other runtime stuff that has been temporarily ripped out
 - control stack scrubbing and bounds checking

15) it would be nice to have a faster way to find the current thread
    from C than calling getpid().  For x86 we can write a bit of asm
    to find the thread pointer in dynamic_values_start[1] and have it
    stored there at thread init.  For other ports something more
    complicated needs doing, unless we can find a register to use for
    the tls base that C promises not to overwrite.  

17) code in target-thread.lisp has brittle dependency on thread.h

18) do we need per-thread alien stack anyway? remembering that alien
    code runs on the control stack, there seem to be only a few palces
    this area gets used at all
